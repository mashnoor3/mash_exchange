{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"num",
				"numCols"
			],
			[
				"PWM",
				"PWM_on"
			],
			[
				"l",
				"LE_N"
			],
			[
				"cur",
				"currentRow"
			],
			[
				"PWM_",
				"PWM_on"
			],
			[
				"uint",
				"uint16_t"
			],
			[
				"sec",
				"sector_counter"
			],
			[
				"se",
				"sector_counter"
			],
			[
				"CLE",
				"CLEAR_COMMAND"
			],
			[
				"const",
				"const"
			],
			[
				"res",
				"restaurant"
			],
			[
				"__",
				"__tablename__"
			],
			[
				"re",
				"Restaurant"
			],
			[
				"de",
				"declarative_base"
			],
			[
				"LED",
				"LedActivation"
			],
			[
				"tas",
				"task"
			]
		]
	},
	"buffers":
	[
	],
	"build_system": "",
	"command_palette":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Users/mashnoorrashid/Desktop/turtle_spiral.py",
		"/Users/mashnoorrashid/Desktop/triangle.py",
		"/Users/mashnoorrashid/Desktop/test.py",
		"/Users/mashnoorrashid/Desktop/switchBitBang.cpp",
		"/Users/mashnoorrashid/Desktop/row_test.cpp",
		"/Users/mashnoorrashid/Desktop/paralleltest.cpp",
		"/Users/mashnoorrashid/Desktop/lm334_model.lib",
		"/Users/mashnoorrashid/Desktop/Lumotune Stuff /flash_test_old.cpp",
		"/Users/mashnoorrashid/Desktop/Lumotune Stuff /flash_test.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/user_configh.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/user_config.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/pwmh.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/pwmh.pp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/pwm.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/flashh.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/flash.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/driveh.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/drive.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/bitbangh.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/bitbang.cpp",
		"/Users/mashnoorrashid/Desktop/SD1-A Backup/main.c",
		"/Users/mashnoorrashid/Desktop/flash_test_old.cpp",
		"/Users/mashnoorrashid/Desktop/Main_Old/switchBitBang.cpp",
		"/Users/mashnoorrashid/Desktop/Lumotune/Firmware/CB9 Program/CB9_Software/CB9/msgProcess.h",
		"/Users/mashnoorrashid/Desktop/Lumotune/Firmware/CB9 Program/CB9_Software/CB9/particle-test2.cpp",
		"/Users/mashnoorrashid/Desktop/Lumotune/Firmware/CB9 Program/CB9_Software/CB9/impcode.nut",
		"/Users/mashnoorrashid/Desktop/fullstacknano/database_setup.py",
		"/Users/mashnoorrashid/Downloads/project_part2.c",
		"/Users/mashnoorrashid/Desktop/CamTest/isp.h",
		"/Users/mashnoorrashid/Desktop/CamTest/encoder.h",
		"/Users/mashnoorrashid/Downloads/lab2.c",
		"/Users/mashnoorrashid/Desktop/hello.cpp",
		"/Users/mashnoorrashid/Desktop/ece224_lab1.c",
		"/Users/mashnoorrashid/Desktop/lab1.c"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"drive",
			"opaq",
			"read",
			"micro",
			"FLASH_counter_out",
			"FLASH_counter_out\nFLASH_counter_out\n",
			"FLASH_counter_out\n",
			"FLASH_counter_out\nFLASH_counter_out\nFLASH_counter_out",
			"FLASH_counter_out\nFLASH_counter_out",
			"FLASH_counter_out",
			"address",
			"uint8",
			"unit8",
			"uint8",
			"three",
			"spi1",
			"pinSetFast",
			"bit",
			"P1",
			"C1",
			"clear",
			"idle",
			"clear",
			"interrupthanndler",
			".written",
			"command",
			"writeToSPI",
			"clear",
			"CLEAR_COMMAND",
			"interrupt",
			"readstat // slave select operations\nconst SS_ENABLE = 0\nconst SS_DISABLE = 1 \n\n// command codes that correspond to different actions\n// on the device firmware (atmel code)\nconst DRIVE_COMMAND = 0x7F\nconst SKIP_COMMAND = 0x7E\nconst CLEAR_COMMAND = 0x7D\nconst INIT_COMMAND = 0x7C\nconst SEND_COMMAND = 0x7B\n\n// SPI results (to determine the result of a row\n// driven on the hardware)\nconst DRIVE_SUCCESS = 0x38\nconst OVERHEATING = 0x40\nconst WRITE_SUCCESS = 0x42\nconst WRITE_FAIL = 0x44\nconst READ_FAIL = 0x46\n\n//Constants used for status register to contain status info such as success, overheating, read/write fail, etc\n//const DRIVE_SUCCESS 0x10 //101x xxxx\n//const OVERHEATING_NOT_MITIGATED 0x04 //xxxx x10x\n//const OVERHEATING_MITIGATED 0x05 //xxxx x11x\n//const WRITE_SUCCESS 0x10 //xxx1 xxxx \n//const WRITE_FAILURE 0x00 //xxxx xxxx \n//const READ_FAIL 0x08 //xxxx 1xxx\n//const CLEAR_INTERRUPT 0xAA \n\n// device defaults\nconst DEFAULT_VOLTAGE = 175\nconst DEFAULT_OPAQUE_TIME = 2\nconst DEFAULT_TRANS_TIME = 2\nconst DEFAULT_MAX_TEMP = 55\nconst DEFAULT_HALF_VOLTAGE = 0\n\n// Device\nBR <- {}\ndevices <- [BR]\n\nSPI <- hardware.spi257 // SPI communication line\n\nfunction interruptHandler (device) { \n    // ignore the rising edge (since we only care about falling edge)\n    if (status_pin.read() == 1) return; \n    \n    readStatus(device)\n     \n}\n\n// if this device is on an actual display (with real pins)\nif(imp.environment() == ENVIRONMENT_MODULE) {\n    BR.pin <- hardware.pinE // This is SS1 on the device hardware\n    \n    RST <- hardware.pin6 // reset pin\n    HV_OFF_PLUS <- hardware.pinC // positive high voltage\n    HV_OFF_MINUS <- hardware.pin8 // negative high voltage\n    \n    // configure slave select pins\n    foreach(device in devices) {\n        device.pin.configure(DIGITAL_OUT_OD_PULLUP) \n    }\n    \n    // deactivates the slave select pin\n    foreach(device in devices){\n        device.pin.write(SS_DISABLE)\n    }\n    \n    // configure the operating parameters of the SPI bus\n    SPI.configure(MSB_FIRST | CLOCK_IDLE_HIGH | CLOCK_2ND_EDGE, 235)\n\n    // configure the parameters of the reset pin\n    RST.configure(DIGITAL_OUT)\n\n    // Enabling reset to be active low \n    RST.write(1)\n    \n    // configure pin11 (D=11)for interrupt\n    status_pin <- hardware.pinD\n    status_pin.configure(DIGITAL_IN, interruptHandler(BR))    \n    \n} else {\n    // this is just a test device\n    foreach(device in devices) {\n        device.pin <- hardware.pin1\n    }\n    \n    // configure the operating parameters of the SPI bus\n    SPI.configure(MSB_FIRST | CLOCK_IDLE_HIGH | CLOCK_2ND_EDGE, 235)\n                \n    RST <- hardware.pin1\n    HV_OFF_PLUS <- hardware.pin1\n    HV_OFF_MINUS <- hardware.pin1\n    \n    // configure the parameters of the reset pin\n    RST.configure(DIGITAL_OUT)\n}\n\nfunction resetDevice(device) {\n    device.currentRow <- 0\n    device.ok <- true\n    device.pin.write(SS_DISABLE)    \n}\n\nforeach(device in devices){\n    resetDevice(device)\n}\n\nfunction resetDisplayStatus() {\n    foreach(device in devices) {\n        device.ok = false\n    }\n}\n\nfunction nextDevice(device) {\n    switch(device) {\n        //case BR: return BL\n        //case BL: return TR\n        //case TR: return TL\n        //case TL: return BR\n        case BR: return BR\n    }\n}\n \nfunction readStatus(device){\n    local result = 0   \n\n    device.pin.write(SS_ENABLE) //chip select \n    result = SPI.readblob(1)\n    device.pin.write(SS_DISABLE)\n\n    server.log(\"M\")\n    server.log(result);\n    server.log(\"M\")\n}\n\n// waits for the SPI to return a byte corresponding to\n// the result of the previous operation\n// returns true if it was a success and false otherwise\nfunction waitForDevices(device) {\n    if(imp.environment() == ENVIRONMENT_CARD) {\n        return true\n    }\n    \n    local overheating = false\n    local done = false\n    local readfail = false\n    local result = 0\n    server.log(\"Watching SPI for result...\")\n    \n    // Watch the SPI to see if the device is done driving\n    // or it failed due to overheating or failed to read from EEPROM\n    while(!done && !overheating && !readfail) {\n        imp.sleep(0.1)\n        // Read data from the SPI to check the result\n        device.pin.write(SS_ENABLE)\n        result = SPI.readblob(1)\n        device.pin.write(SS_DISABLE)\n        server.log(result[0]);\n        \n        done = result[0] == DRIVE_SUCCESS\n        readfail = result[0] == READ_FAIL\n        overheating = result[0] == OVERHEATING\n    }\n    \n    if(done) {\n        server.log(\"Success\")\n        device.ok = true\n        return true\n    } else if (readfail) {\n        server.log(\"Reading failed from eeprom: will stop driving\")\n        return false\n    } else if (overheating) {\n        server.log(\"Overheating: will stop drivingLALA\")\n        return false\n    }\n}\n\n// waits for the SPI to return a byte corresponding to\n// the result of writing data\n// returns true if it was a success and false otherwise\nfunction waitForWritingDevice(device) {\n    if(imp.environment() == ENVIRONMENT_CARD) {\n        return true\n    } \n    \n    local writefail = false\n    local done = false\n    local result = 0\n    server.log(\"Watching SPI for result...\")\n    \n    // Watch the SPI to see if the device is done driving\n    // or it failed writing to EEPROM\n    while(!done && !writefail) {\n        imp.sleep(0.01)\n        \n        // Read data from the SPI to check the result\n        device.pin.write(SS_ENABLE)\n        result = SPI.readblob(1)\n        device.pin.write(SS_DISABLE)\n        done = (result[0] == WRITE_SUCCESS) || (result[0] == DRIVE_SUCCESS)\n        writefail = result[0] == WRITE_FAIL\n    }\n    \n    if(done) {\n        server.log(\"Success.\")\n        return true\n    } else if(writefail) {\n        server.log(\"Writing to eeprom failed: will stop writing.\")\n        return false\n    }\n}\n\n// initializes the device parameters\nfunction initDevice(body, device) {\n    device.pin.write(SS_ENABLE)\n    \n    local variableBytes = blob(9)\n    // 1. write the command byte (required for\n    // all SPI communication with the device)\n    variableBytes.writen(INIT_COMMAND, 'b')\n    \n    // 2. write TWO bytes for the number of columns\n    local width = body.width.tointeger()\n    variableBytes.writen((width >> 8), 'b')\n    variableBytes.writen((width & 0xFF), 'b')\n    \n    // 3. write TWO bytes for the number of rows\n    local height = body.height.tointeger()\n    variableBytes.writen((height >> 8), 'b')\n    variableBytes.writen((height & 0xFF), 'b')\n    \n    // 4. Write one byte for the voltage\n    local voltage = (\"voltage\" in body) ? body.voltage.tointeger() : DEFAULT_VOLTAGE\n    variableBytes.writen(voltage, 'b')\n    \n    // 5. Write one byte for the opaqueTime\n    local opaqueTime = (\"opaqueTime\" in body) ? body.opaqueTime.tointeger() : DEFAULT_OPAQUE_TIME\n    variableBytes.writen(opaqueTime, 'b')\n    \n    // 6. Write one byte for the transTime\n    local transTime = (\"transTime\" in body) ? body.transTime.tointeger() : DEFAULT_TRANS_TIME\n    variableBytes.writen(transTime, 'b')\n    \n    // 7. Write one byte for the maxTemp\n    local maxTemp = (\"maxTemp\" in body) ? body.maxTemp.tointeger() : DEFAULT_MAX_TEMP\n    variableBytes.writen(maxTemp, 'b')\n\n    // 8. Write one byte for halfVoltage check \n    local halfVoltage = (\"halfVoltage\" in body) ? body.halfVoltage.tointeger() : DEFAULT_HALF_VOLTAGE\n    variableBytes.writen(halfVoltage, 'b')\n\n    // finally send the variables as bytes through the SPI\n    server.log(variableBytes)\n    SPI.write(variableBytes)\n    \n    device.pin.write(SS_DISABLE)\n}\n\n// Writes a sequence of bytes to the SPI in the\n// documented sequence.\nfunction writeToSPI(data, device) {\n    // NOTE: all bytes written to the SPI \n    // are negated due to inverters on hardware\n    device.pin.write(SS_ENABLE)\n    \n    // write the command byte\n    local commandByte = blob(1)\n    commandByte.writen(data.command, 'b')\n    server.log(commandByte)\n    SPI.write(commandByte)\n    \n    // drive the row if it exists\n    if(\"row\" in data) {\n        server.log(data.row)\n        SPI.write(data.row)\n    }\n    \n    device.pin.write(SS_DISABLE)\n}\n\n// start the clearing process on the display\nfunction startClearing(body) {\n    server.log(\"Started clearing.\")\n    \n    // initialize the device params\n    foreach(device in devices){\n        initDevice(body, device)\n    }\n    local success = waitForDevices(BR)\n    if(!success) {\n        return finish()\n    }\n    \n    // send the clear command\n    foreach(device in devices){\n        writeToSPI({command = CLEAR_COMMAND}, device)\n    }\n    waitForDevices(BR)\n    finish()\n}\n\n// start the driving process on the display\nfunction startDriving(body) {\n    server.log(\"Started driving.\")\n    \n    local success = true;\n    \n    // keep driving until we reach the end of the data\n    // or the device fails an operation\n    while(success && BR.currentRow < BR.totalRows) {\n        foreach(device in devices){\n            local driveData = {}\n            device.currentRow++\n\n            server.log(\"Driving ROW #\" + device.currentRow)\n            driveData.command <- DRIVE_COMMAND\n        \n            writeToSPI(driveData, device)\n        }\n        success = waitForDevices(BR)\n    }\n    \n    finish()\n}\n\n// finishes a session and shuts down by resetting globals\n// and turning pins off\nfunction finish() {\n    server.log(\"Finished driving! Shutting down.\")\n    server.log(\"FINISH: \" + imp.getmemoryfree())\n\n    // ensure devices are reset\n    foreach(device in devices){\n        resetDevice(device)\n    }\n    \n    RST.write(1)\n    \n    // ensure SS are off\n    foreach(device in devices){\n        device.pin.write(SS_DISABLE)\n    } \n    \n    // Turn off HV Supplies\n    HV_OFF_MINUS.write(1)\n    HV_OFF_PLUS.write(1)\n    \n    agent.send(\"finish\", null)\n}\n\nfunction sendImgData(body){\n    server.log(\"Started sending img data\")\n    // reset current image data\n    local rows = body.rows\n    local currentRow = 0\n            \n    local device = devices[0]\n    device.totalRows <- rows.len()\n                \n    initDevice(body, device)\n            \n    local success = waitForWritingDevice(device)\n    if(!success) {\n        resetDevice(device);\n        return agent.send(\"finishSend\", null)\n    }\n    while(success && currentRow < rows.len()) {\n        local driveData = {}\n        local row = rows[currentRow++]\n                    \n        driveData.command <- SEND_COMMAND\n        driveData.row <- row\n                    \n        writeToSPI(driveData, device)\n        success = waitForWritingDevice(device)\n    }\n                \n    server.log(\"Finished sending img data\")\n    resetDevice(device)\n    agent.send(\"finishSendImg\", success)\n}\n        \n// What to do when agent sends commands\nagent.on(\"startDriving\", startDriving)\nagent.on(\"startClearing\", startClearing)\nagent.on(\"sendImgData\", sendImgData)\n\nfunction wakeup() {\n    server.log(\"Device online.\")\n    imp.wakeup(5, wakeup)\n}\nwakeup()\n\ninterrupth",
			"readstat",
			"buffer",
			"master",
			"ss_disab",
			"device.pin.write(SS_ENABLE)\n    localresult = SPI.readblob(1)\n    device.pin.write(SS_DISABLE)",
			"server.log(\"m",
			"write",
			"spi_write",
			"wait",
			"waitForWritingDevice",
			"waitForDevices",
			"ss_",
			"waitForDevices",
			"writeToSPI",
			"half",
			"disable",
			"disable = 1",
			"disable=1",
			"disable = 1",
			"delay",
			"tmp2",
			"BPB_BytsPerSec",
			"lcd",
			"buffer",
			"build",
			"clusterc",
			"buildc",
			"sector",
			"delay_buff",
			"stop",
			"file_nu",
			"filetype",
			"next",
			"stop",
			"intit",
			"build_cl",
			"play_spee",
			"playspeed",
			"build_cl",
			" cc",
			"cc ",
			"cc",
			"buildcl",
			"df",
			"read",
			"SD_read",
			"read",
			"SD",
			"read",
			"lba",
			"SD_read_lba",
			"SD read lba",
			"sd_read",
			"lba",
			"AUD_FULL_BASE",
			"buildCluster",
			"play_speed",
			"search_for",
			"playsong",
			"LCD_in",
			"data_file",
			"init",
			"new",
			"new ta",
			"submit",
			"new",
			"events",
			"submit"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"replace":
	{
		"height": 0.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true
}
